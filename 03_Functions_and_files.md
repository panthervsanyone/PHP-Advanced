# Урок 3. Файлы, функции

## Файлы

Работа с файлами состоит из трех этапов:  

1. Открытие файла.
2. Манипуляции с данными.  
3. Закрытие файла.

### Открытие файла

Для открытия файла используется функция **fopen**. Параметрами функции является имя файла и режим открытия файла. Функция возвращает дескриптор файла, который позволяет в дальнейшем работать с уже открытым файлом.

```php
$file = fopen('file.txt', 'r+');
```
 
- **r** – открытие файла только для чтения
- **r+** – открытие файла одновременно на чтение и запись
- **w** – создание нового пустого файла. Если на момент вызова уже существует такой файл, то он уничтожается
- **w+** - аналогичен r+, только если на момент вызова файл такой существует, его содержимое удаляется
- **a** – открывает существующий файл в  режиме записи, при этом указатель сдвигается на  последний байт файла (на конец файла)
- **a+** - открывает файл в режиме чтения и записи при этом указатель сдвигается на последний байт файла (на конец файла). Содержимое файла не удаляется

### Работа с данными файла

**`fgets()`** используется для чтения строк из файла, принимает один обязательный и один необязательный параметр. Первый параметр - обработчик файла, file handler, который создается функцией `fopen`. Второй параметр - количество символов.

**`fwrite()`** применяется для записи в файл. У нее есть три параметра: обязательный file handler, обязательный параметр "что писать в файл", и необязательный - указание количества символов.

Файл так же можно прочитать сразу весь, в массив, при помощи функции **`file()`**. Эта функция принимает единственный параметр - имя файла, и не требует handler-а.

При помощи **`feof()`** с единственным параметром handler можно проверить, закончился ли файл.

### Закрытие файла

Файл закрывается вызовом функции **`fclose()`**, принимающей единственным параметром хэндлер файла.

### Пример работы с файлами
Задача. Перенести с файла counter.txt текст в файл file.txt. Вывести результат. Закрыть файл
```php
//читаем файл в массив  
$file_array = file('counter.txt');
//открытие файла
$file = fopen('file.txt', 'a+');
//проверка, не закончился ли файл
//чтение из файла
fwrite($file, $file_array[0]);
$s = fgets($file);
echo $s;

//закрытие файла
fclose($file);
```
 
Чтобы ознакомиться с другими функциями работы с файлами, перейдите по ссылке ниже.
[Все функции для работы с файлами](http://www.php.su/articles/?cat=fs&page=005)

## Функции php

Функцией называется фрагмент программного кода, обладающий уникальным именем и предназначенный для решения конкретной задачи. Функция вызывается по имени в разных точках программы, что позволяет многократно выполнять фрагмент с указанным именем. Преимущество такого решения заключается в том, что блок кода пишется всего один раз, а затем легко модифицируется по мере необходимости. 

Функции могут создаваться в любой точке программ PHP. 
Можно разместить все функции, используемые сценарием, в самом начале сценарного файла. 
Лучше выделить функций в отдельный файл (называемый библиотекой). 

Определение функции обычно состоит из трех частей: 
* имени функции; 
* круглых скобок, в которых перечисляются необязательные входные параметры, разделенные запятыми; 
* тела функции, заключенного в фигурные скобки. 
```php
function имя_функции ([$параметр1. $параметр2, .... $параметрn]) { 
	тело функции 
}
```


## Пользовательские функции
Определили функцию:
```php
<?php
  function hello() {
    echo "Привет из функции";
    return true;
  }
?>
```
! Без return можно, но не нужно.

Вызвали функцию:
```php
<?php
  // вызов функции
  hello();
?>
```
Передали данные в функцию:
```php
<?php
  function hello($my_name) {
    echo "Привет $my_name !!!";
    return 1;
  }
   $name = “Nick”;
   hello($name);
?>
```

## Написание своей функции
Возвращает значение из функции конструкция return:
```php
function myFunc($n){
	return $n*$n;
}
$kvadrat = myFunc(2);
// теперь переменная $kvadrat = 4
```
В отличии от C можно возвращать любой тип данных, включая массивы.
Сразу несколько значений функция вернуть не может, но вполне можно сложить несколько данных в ассоциативный массив и вернуть его. 
Если в функции нет конструкции return, то считается что функция вернула NULL (по умолчанию).
Но лучше стараться всегда что-то возвращать функцией, как правило хорошего тона.
Если нечего возвращать, напишите:  
```php
return true;
```
Встретив в теле функции конструкцию return интерпретатор далее функцию не выполняет, только возвращает значение.


## Параметры по умолчанию
```php
<?php
  function hello($name, $surname = “Ivanovich” ) {
    echo "Привет $name $surname !!!";
    return 1;
  }

   $name = “Nick”;
   hello($name);
?>
```
Если при вызове функции ей передать необязательный параметр, то она его использует. Если не передать, то функция использует значение из своего объявления (значение по умолчанию)

Если мы объявляем функцию с параметрами по умолчанию, то вначале должны идти обязательные параметры, а потом не обязательные.
Следующий код будет не корректен:
```php
<?php 
	function hello($name = 'Mike', $h){ 
		echo "<h$h>Hello, $name!</h$h>"; 
	} // Код не корректен 
?> 
```
Здесь при вызове функции я уже не могу пропустить первый параметр, а он у нас не обязательный, то есть, я не могу записать вызов функции так:
```php
<?php 
	hello( , 1); 
	// Ошибка 
?>
```
## Переменное число параметров

Иногда бывает удобно передавать любое количество переменных в функцию. К примеру что бы вывести каждую строковую переменную применив к ним какое-либо форматирование:
**ВАЖНО:
Можно задавать при вызове функции больше параметров, чем описано в функции. Лишние просто проигнорируются. 
Но меньше задавать НЕЛЬЗЯ.**
```php
function myecho(){ 
        for($i=0; $i<func_num_args(); $i++){
            echo func_get_arg($i) . "<br>\n";
        }
        //можно использовать foreach
} 
//выведем отформатированные строки
myecho("First sentenc!!!", "Second sentenc!!!", "Third sentence!!!");
```
Функции для доступа к «лишним» параметрам:
* **int func_num_args()** – возвращает общее число аргументов, переданных функции.
* **mixed func_get_arg(int $num)** – возвращает значение аргумента с номером $num, заданного при вызове функции (начиная с 0).
* **list func_get_args()** – возвращает список всех аргументов, указанных при вызове функции


## Ссылки
Ссылки в PHP - это средство доступа к содержимому одной переменной под разными именами.
Жесткая ссылка представляет собой просто переменную, которая является синонимом другой переменной. Многоуровневые ссылки (то есть, ссылка на ссылку на переменную, как это можно делать, например, в Perl) не поддерживаются. Так что не стоит воспринимать жесткие ссылки серьезнее, чем синонимы.Чтобы создать жесткую ссылку, нужно использовать оператор & (амперсанд). Например:
```php
$a=10;
$b = &$a; 
// теперь $b — то же самое, что и $a
$b=0; 
// на самом деле $a=0
echo "b=$b, a=$a"; 
// Выводит: "b=0, a=0»
```
Ссылаться можно не только на переменные, но и на элементы массива:
```php
$A=array('a' => 'aaa', 'b' => 'bbb');
$b=&$A['b']; 
// теперь $b — то же, что и элемент с индексом 'b' массива
$b=0; 
// на самом деле $A['b']=0;
echo $A['b']; // Выводит 0
```
Впрочем, элемент массива, для которого планируется создать символическую ссылку, может и не существовать. Как в следующем случае:
```php
$A = array('a' => 'aaa', 'b' => 'bbb');
$b = &$A[‘с'];
// теперь $b — то же, что и элемент с индексом 'c' массива echo "Элемент с индексом 'c': (".$A['c'].")";
```
В результате выполнения рассмотренного скрипта, хотя ссылке $b и не было ничего присвоено, в массиве $A создастся новый элемент с ключом c и значением — пустой строкой. 
То есть, жесткая ссылка на самом деле не может ссылаться на несуществующий объект, а если делается такая попытка, то объект создается.
Примечание: Если убрать строку, в которой создается жесткая ссылка, то будет выведено сообщение о том, что элемент с ключом c не определен в массиве $A.

## Удаление ссылки

При удалении ссылки, просто разрывается связь имени и содержимого переменной. Это не означает, что содержимое переменной будет разрушено:
```php
$a = 1;
$b =& $a;
unset($a); 
```
Этот код не сбросит $b, а только $a.
Переменная $a, но которую ссылается переменная $b удалится. Но значение, которое было в $b на момент удаления $a так и останется.
Фактически $b станет независимой переменной.
```php
unset($b); 
```
Теперь получается что удалится только $b (ссылка на $a). Сама переменная $a при этом не пострадает.

## Передача параметров по ссылке
Если необходимо разрешить функции изменять переданные аргументы за ее пределами, вы должны передавать их по ссылке. 
Для того, чтобы аргумент был передан по ссылке, необходимо указать знак & (амперсанд) перед именем параметра в определении функции:
```php
function foo(&$my_color) {  
     // теперь параметр будет ссылаться на оригинальное значение
     $my_color = 'синий';      
      // присваиваем новое значение
  }
  $color = 'красный';
  foo($color);
  echo $color;    // выведет: синий


function funct(&$string){
	$string .= 'а эта внутри.';
}
$str = 'Эта строка за пределами функции, ';
funct($str);
echo $str;    
// Выведет 'Эта строка за пределами функции, а эта внутри.'
```

## Возвращение по ссылке из функций

Если можно передавать переменные по ссылке в функцию, то так же можно возвращать ссылки из функции. Для этого нужно записать знак амперсанда перед названием функции в её определении. Вы также должны записать знак амперсанда (=&) при присвоении функции переменной, в противном случае вы просто присвоите значение, а не ссылку.
```php
$numWidgets = 10; 
function &getNumWidgets(){ 
    	global $numWidgets;
    	return $numWidgets; 
} 
$Numwidgetsref = &getNumWidgets(); 
$Numwidgetsref--; 
echo " \$numWidgets = $numWidgets<br> ";                // Выведет " 9 ". 
echo " \$numWidgetsRef = $Numwidgetsref<br> ";      // выводит " 9 ". 
```
В этом примере функция getNumWidgets() находит глобальную переменную $numWidgets и возвращает ссылку на неё. Затем мы вызываем getNumWidgets() , которая сохраняет возвращенные ссылки в $Numwidgetsref, и уменьшает значение в переменной, на которую указывает $Numwidgetsref. Это то же самое значение, на которое указывает переменная $numWidgets, как можно увидеть из результата работы функции echo.

## Вызов функции через переменную

Существует еще один вариант вызова функции в PHP — через переменную. 

Используется редко, но может попасться у кого-нибудь в коде:
```php
<?php 
	function hello($name, $h){ 
		echo "<h$h>Hello, $name!</h$h>"; 
	} 

	$myvar = 'hello'; 
	// Значение в переменной - строка совпадает с именем функции 
	
	$myvar('Nick', 34);	
	// Выводим функцию через переменную 
?> 
```
## Область видимости переменных 
Переменные бывают 
* **локальные**
* **глобальные**

**Локальная —переменная**, которая находится внутри функции PHP и она не доступна из вне. Мы можем объявить переменную внутри функции, но вызвать ее или обратиться к ней не из функции — не можем.

**Глобальная область видимости** — это те переменные, которые объявляются вне функций PHP и они доступны из любой части программного кода.
**Как обратиться к локальной переменной внутри функции?** Можно объявить переменную внутри функции с помощью ключевого слова global. 
```php
function hello($name){ 
	echo "Hello, $name!"; 
	global $name; 
	$name = 'Vasya'; 
} 

hello('Zack'); 
$name = 'Mike'; 

hello($name); 
echo $name; 
// Здесь уже будет Vasya
```

## Массив $GLOBALS

Мы объявляем переменную PHP и присваиваем ей значение: 
```php
$name = 'Mike'; 
```
У PHP внутри есть массив GLOBALS. 
Когда мы присваиваем переменной значение, PHP выделяет в массиве GLOBALS ячейку памяти под названием, совпадающей с названием нашей переменной: $GLOBALS['name'] = 'Mike'. 

Переменные, объявленные внутри функции не попадают в этот массив.
```php
function hello($name){ 
	echo "Hello, $name!"; 
	$GLOBALS['name'] = 'Vasya'; т.с. 
} 

hello('Zack'); 
$name = 'Mike'; 

hello($name); 
echo $name; 
// Здесь уже будет Vasya
```
## Как работает инструкция global?

Конструкция global $a говорит о том, что переменная $a в нашей функции является синонимом глобальной переменной $a  из вне функции. А синоним в терминах РНР – это и есть ссылка. 
Выходит что global создает ссылку и вот как это воспринимается транслятором:
```php
function test(){
	global $a;
	$a = 10;	
}
ЭКВИВАЛЕНТНО:
function test(){
	$a = &$GLOBALS[‘a’];
	$a = 10;	
}
```
Получается оператор unset($a) при применении его в функции не удалит глобальную переменную, а только отвяжет от неё ссылку.

Если же нам нужно совсем удалить глобальную $a прям из функции, то нам нужно воспользоваться массивом GLOBALS:
```php
function delete(){
	unset($GLOBALS[‘a’]);
}
$a = 100;
deleter();
echo $a;
//Предупреждение: переменная $a не определена.
```

## Статические переменные
Для объявления статических переменных используется конструкция static – собственно она говорит о том, что автоматически уничтожать указанную переменную для нашей функции между её вызовами не нужно.
Она «как бы» переносит значения от вызова к вызову функции.
```php
function selfcount(){
	static $count = 0;
	$count++;
	echo $count;
}

for($i=0; $i<5; $i++) selfcount();
```
Будет выведена строка 12345, а если убрать статик, то мы увидим на экране 11111.

Что интересно, присваивание static $count = 0 отработало только один раз и при последующих вызовах функции переменная $count не обнулялась.
Это особенность объявления static


## Рекурсивные функции
Рекурсивные функции – это функции, которые вызывают сами себя до выполнения определенного условия. 
Рекурсивная функция, которая вызывает себя бесконечно вызывает ошибку, нужно быть внимательным.

Рассмотрим ставший уже стандартным вопросом на собеседованиях пример рекурсивной функции – факториал из некоторого числа n, равный значению 2*3*4*…*n
```php
function factor($n){
	if($n<=0) return 1;
	else return $n*factor($n-1);
}

echo factor(20);
```

## Советы по использованию функций

* Не допускайте огромных функций. Лучше большие функции дробить на маленькие (20-30 строк кода), по возможности независимые и желательно полезные сами по себе. Тогда повысится вероятность многократности использования такого кода.
* Утверждение, что затрачиваются ресурсы на вызов функций и нужно писать их меньше не верно. Часто несколько простых функций отрабатывают быстрее одной громоздкой и сложной. К тому же объединить функции легко а вот разбить большую на несколько сложнее.
* Не пишите свои функции там, где можно использовать стандартные функции PHP. Свои функции быстрее работать не будут НИКОГДА!
* Не пытайтесь оптимизировать программу, искусственно превращая параметры-значения функций в параметры-ссылки – это не даст прироста производительности. Используйте ссылки только тогда, когда процедура действительно должна изменить свой аргумент.


[Домашнее задание](03_homework.md)

[Четвертый Урок](04_Strings_and_arrays.md)
